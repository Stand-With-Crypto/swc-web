generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

// generator erd {
//   provider  = "prisma-erd-generator"
//   tableOnly = true
// }

datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

model AuthenticationNonce {
  id String @id

  @@map("authentication_nonce")
}

// In the interest of preparing the site for internationalization
// we'll want to store all addresses in a normalized format that applies globally
// this is why we don't use more US-centric names like "state", "addressLine1", etc
// these names are based on the google places api
model Address {
  id                       String   @id @default(uuid())
  // For now all our addresses will be persisted via google place so this is required. This may change in the future
  googlePlaceId            String   @unique @map("google_place_id")
  formattedDescription     String   @map("formatted_description") // We could compute this from the fields, but in the interest of matching the user selection exactly let's persist for now. ex: 123 East 86th St, Apt 13a, New York, NY 06890
  streetNumber             String   @map("street_number") // ex: 123
  route                    String   @map("route") // ex: East 86th St
  subpremise               String   @map("subpremise") // ex: Apt 13a
  locality                 String   @map("locality") // ex: Boston
  administrativeAreaLevel1 String   @map("administrative_area_level_1") // ex: NY
  administrativeAreaLevel2 String   @map("administrative_area_level_2") // ex: New York County (not used in US)
  postalCode               String   @map("postal_code") // ex: 06890
  postalCodeSuffix         String   @map("postal_code_suffix") // ex 7620
  countryCode              String   @map("country_code")
  datetimeUpdated          DateTime @updatedAt @map("datetime_updated")
  datetimeCreated          DateTime @default(now()) @map("datetime_created")

  userActionEmails UserActionEmail[]
  users            User[]

  @@map("address")
}

// A user can interact with our platform multiple ways. 
// Sometimes that user will be signing up via coinbase, 
// sometimes a user will be signing up via a wallet on the website, or multiple wallets
// sometimes they won't be logged in at all but we'll need to cache a session id for them so that if they log in with a eth address later we can associate their actions with the new address. 
// We'll need to track these different "user markers" with their own respective metadata, and join these related models with a User table to provide a single view of a user
// A key assumption we're making about how this model will be used:

// A user has a one-to-one relationship with a crypto address. We could model it so a user has a one-to-many relationship with adddresses, and try to deduplicate/merge actions a user takes across multiple wallets.
// given the introduced complexity, and the fact we're not confident that's the desired user behavior (maybe someone wants to represent themselves as two addresses/ENS like if they have a personal wallet and corporation wallet), we opt instead for one-to-one

// A user has a many-to-many relationship with an email.
// Example where a user will have multiple emails: They opt in on the coinbase app, and we associate that email with them, and then later on they go to their profile page and set a different email address as their "primary" email address. We don't want to loose the association to the coinbase opt in
// Example where an email may have multiple users: A user logs in with multiple wallets, but wants to use the same email on their profile page for both. We'll need to ensure each of these wallets seperately "verifies" they own the email address
// The user will need a "primary" email address so we are only sending marketing messages to one email address. We can make this togglable in their profile page

// A user has a one-to-many relationship with a session. A session will only be persisted if a user is not logged in and performs an action on the site. If they are logged in, we will associate the action with thier crypto address.
// Once we identify a session is associated with a crypto address (the user logs in to the app in the same session after performing an action), we'll want to merge the session and crypto address under the same user. We will maintain the session fk on the action to keep the context that the action was originally linked to a session instead
model User {
  id                        String            @id @default(uuid())
  datetimeUpdated           DateTime          @updatedAt @map("datetime_updated")
  datetimeCreated           DateTime          @default(now()) @map("datetime_created")
  fullName                  String            @default("") @map("name")
  phoneNumber               String            @default("") @map("phone_number")
  address                   Address?          @relation(fields: [addressId], references: [id])
  addressId                 String?           @map("address_id")
  isPubliclyVisible         Boolean           @map("is_publicly_visible")
  sampleDatabaseIncrement   Int               @default(0) // TODO delete
  primaryUserEmailAddress   UserEmailAddress? @relation("asPrimaryUserEmailAddress", fields: [primaryUserEmailAddressId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  primaryUserEmailAddressId String?           @unique @map("primary_user_email_address_id")
  // We'll collect and capture this information in our product analytics tools, but we'll also want to be able to 
  // use this metadata to query our relationship database. This information will only be populated if users
  // opt in to our cookies
  acquisitionReferer     String @map("acquisition_referer") 
  acquisitionSource     String @map("acquisition_source") 
  acquisitionMedium     String @map("acquisition_medium") 
  acquisitionCampaign     String @map("acquisition_campaign") 

  userCryptoAddress  UserCryptoAddress?
  userSessions       UserSession[]
  userEmailAddresses UserEmailAddress[] @relation("userEmailAddresses")
  userActions        UserAction[]

  @@index([addressId])
  @@map("user")
}

// A "user" that is performing actions on our platform but has not logged in to any system yet will have that action associated with a user session
// A user session will only be linked to user actions on creation if a different authenticated user type (email or wallet) is not already associated with the action
model UserSession {
  id              String   @id @default(uuid())
  userId          String   @map("user_id")
  user            User     @relation(fields: [userId], references: [id])
  datetimeUpdated DateTime @updatedAt @map("datetime_updated")
  datetimeCreated DateTime @default(now()) @map("datetime_created")

  userActions UserAction[]

  @@index([userId])
  @@map("user_session")
}

enum UserEmailAddressSource {
  COINBASE_AUTH
  THIRDWEB_EMBEDDED_AUTH
  USER_ENTERED
}

model UserEmailAddress {
  id              String                 @id @default(uuid())
  isVerified      Boolean                @map("is_verified")
  address         String
  userId          String                 @map("user_id")
  user            User                   @relation("userEmailAddresses", map: "userEmailAddresses", fields: [userId], references: [id])
  source          UserEmailAddressSource
  datetimeUpdated DateTime               @updatedAt @map("datetime_updated")
  datetimeCreated DateTime               @default(now()) @map("datetime_created")

  userActions               UserAction[]
  asPrimaryUserEmailAddress User?        @relation("asPrimaryUserEmailAddress")

  @@unique(map: "user_email_address_unique_constraint", [address, userId])
  @@index([userId])
  @@map("user_email_address")
}

// enum Web3AddressCustodian {
//   SELF_CUSTODY
//   THIRDWEB
// }

enum SupportedUserCryptoNetwork {
  ETH
}

// Using ThirdWeb a user can create multiple "accounts", one per wallet. They can also have some that are self-custodied, and some that are being custodied by ThirdWeb (email, google login, etc)
model UserCryptoAddress {
  id              String                     @id @default(uuid())
  cryptoNetwork   SupportedUserCryptoNetwork @default(ETH) @map("crypto_network")
  address         String                     @map("address")
  // TODO figure out how to detect this via thirdweb sdk and then add it to the model
  // initialCustodian Web3AddressCustodian
  datetimeUpdated DateTime                   @updatedAt @map("datetime_updated")
  datetimeCreated DateTime                   @default(now()) @map("datetime_created")
  userId          String                     @unique @map("user_id")
  user            User                       @relation(fields: [userId], references: [id])

  userActions UserAction[]

  @@unique([address, cryptoNetwork])
  @@index([address])
}

enum UserActionType {
  EMAIL
  CALL
  DONATION
  OPT_IN
  TWEET
  NFT_MINT
}

model UserAction {
  id                  String             @id @default(uuid())
  userId              String             @map("user_id")
  user                User               @relation(fields: [userId], references: [id])
  campaignName        String             @map("campaign_name")
  // Because a user could be in a number of different states (logged in, not logged in, etc) we want to track the different types of users that could be performing an action
  // an action will only ever be associated with one of these types of users
  userCryptoAddressId String?            @map("crypto_address_id")
  userCryptoAddress   UserCryptoAddress? @relation(fields: [userCryptoAddressId], references: [id])
  userSessionId       String?            @map("user_session_id")
  userSession         UserSession?       @relation(fields: [userSessionId], references: [id])
  userEmailAddressId  String?            @map("user_email_address_id")
  userEmailAddress    UserEmailAddress?  @relation(fields: [userEmailAddressId], references: [id])
  datetimeUpdated     DateTime           @updatedAt @map("datetime_updated")
  datetimeCreated     DateTime           @default(now()) @map("datetime_created")
  // Because some actions that are not NFT_MINT can still have an nft associated with them, we want to have an optional fk constrain on all actions
  nftMintId           String?            @unique @map("nft_mint_id")
  nftMint             NFTMint?           @relation(fields: [nftMintId], references: [id])
  actionType          UserActionType     @map("action_type")

  // We'll need in-memory logic to validate and verify only one action type is every associated with a UserAction
  userActionEmail    UserActionEmail?
  userActionCall     UserActionCall?
  userActionDonation UserActionDonation?
  userActionOptIn    UserActionOptIn?

  @@index([datetimeCreated])
  @@index([userId, campaignName])
  @@index([userCryptoAddressId])
  @@index([userSessionId])
  @@index([nftMintId])
  @@index([userEmailAddressId])
  @@map("user_action")
}

enum UserActionOptInType {
  SWC_SIGN_UP_AS_SUBSCRIBER
  SWC_SIGN_UP_AS_MEMBER
}

model UserActionOptIn {
  id         String              @id @default(uuid())
  userAction UserAction          @relation(fields: [id], references: [id])
  optInType  UserActionOptInType @map("opt_in_type")

  @@index([id])
  @@map("user_action_opt_in")
}

model UserActionEmail {
  id                        String                     @id @default(uuid())
  userAction                UserAction                 @relation(fields: [id], references: [id])
  senderEmail               String                     @map("sender_email")
  fullName                  String                     @map("full_name")
  phoneNumber               String                     @map("phone_number")
  address                   Address                    @relation(fields: [addressId], references: [id])
  addressId                 String                     @map("address_id")
  userActionEmailRecipients UserActionEmailRecipient[]

  @@index([id])
  @@index([addressId])
  @@map("user_action_email")
}

model UserActionEmailRecipient {
  id                String          @id @default(uuid())
  userActionEmailId String          @map("user_action_email_id")
  userActionEmail   UserActionEmail @relation(fields: [userActionEmailId], references: [id])
  dtsiSlug          String          @map("dtsi_slug")

  @@index([userActionEmailId])
  @@map("user_action_email_recipient")
}

model UserActionCall {
  id                   String     @id @default(uuid())
  userAction           UserAction @relation(fields: [id], references: [id])
  // TODO determine if these need to be nullable in the future
  recipientDtsiSlug    String     @map("recipient_dtsi_slug")
  recipientPhoneNumber String     @map("recipient_phone_number")

  @@index([id])
  @@map("user_action_call")
}

enum DonationOrganization {
  STAND_WITH_CRYPTO
  FAIRSHAKE
}

model UserActionDonation {
  id                 String               @id @default(uuid())
  userAction         UserAction           @relation(fields: [id], references: [id])
  // TODO determine if these need to be nullable in the future
  amount             Decimal              @map("amount")
  amountCurrencyCode String               @map("amount_currency_code")
  amountUsd          Decimal              @map("amount_usd")
  recipient          DonationOrganization

  @@index([id])
  @@map("user_action_donation")
}

enum NFTCurrency {
  ETH
}

// TODO determine if this actually should be a model or just an enum
// my gut is that we want to be able to spin up new mints in the future without having to migrate the db
// if that's the case then we want a freestanding model
model NFT {
  id               String      @id @default(uuid())
  name             String
  cost             Decimal     @map("cost")
  costCurrencyCode NFTCurrency @map("cost_currency_code")
  datetimeUpdated  DateTime    @updatedAt @map("datetime_updated")
  datetimeCreated  DateTime    @default(now()) @map("datetime_created")

  nftMint NFTMint[]
  // TODO Web3 info about address/contract/etc/price (img)

  @@index([id])
  @@map("nft")
}

model NFTMint {
  id                     String      @id @default(uuid())
  nftId                  String      @map("nft_id")
  nft                    NFT         @relation(fields: [nftId], references: [id])
  datetimeUpdated        DateTime    @updatedAt @map("datetime_updated")
  datetimeCreated        DateTime    @default(now()) @map("datetime_created")
  costAtMint             Decimal     @map("cost_at_mint")
  costAtMintCurrencyCode NFTCurrency @map("cost_at_mint_currency_code")
  costAtMintUsd          Decimal     @map("cost_at_mint_usd")

  userActions UserAction[]

  @@index([id])
  @@index([nftId])
  @@map("nft_mint")
}
